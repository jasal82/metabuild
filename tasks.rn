use arch::*;

mod artifactory;
mod python;
mod core;

use python::Venv;

fn step(msg) {
    println!("{}", str::paint(format!("{}...", msg)).blue().bold());
}

pub fn fs_examples(args) {
    // Create a temporary directory (will be deleted when the object is dropped)
    step("Creating temporary directory");
    let t = fs::TempDir::new()?;
    println!("Temp dir {}", t.path());
    
    // Find all .rn files in the current directory and subdirectories and return
    // a list of relative paths to them
    step("Finding .rn files in current dir and subdirs");
    let files = fs::glob("**/*.rn");
    for file in files {
        println!("File {}", file);
    }

    // Copy all .rn files in the current directory and subdirectories to a
    // temporary directory and test that the files are there
    step("Copying .rn files to temp dir");
    fs::copy_glob("**/*.rn", t.path());
    if fs::is_file(t.path() + "/.mb/modules/core/mod.rn") {
        println!("File exists");
    }

    // Create a temporary file (will be deleted when the object is dropped)
    step("Creating temporary file");
    let f = fs::File::temp()?;

    // Write some data to it
    step("Writing to temporary file");
    f.write("Hello world!");

    // Rewind the file and read the data
    step("Reading from temporary file");
    f.rewind();
    let s = f.read()?;

    // Print the data and some file information
    println(s);
    println!("File length {}", f.len());
    println!("File path {}", f.path());
}

pub fn arch_examples(args) {
    step("Create a .tar.gz archive");
    let targz = arch::TarGz::create("test.tar.gz")?;

    step("Append a file");
    targz.append_file("sick.rn", "sick.rn")?;

    step("Append a directory");
    targz.append_dir_all(".", "tests");

    step("Create a .zip archive");
    let zip = arch::Zip::create("test.zip")?;

    step("Append a file");
    zip.append_file("sick.rn", "sick.rn")?;

    step("Append a directory");
    zip.append_dir_all(".", "tests");

    step("Remove files");

}

pub fn py_examples(args) {
    // Create a temporary directory (will be deleted when the object is dropped)
    step("Creating temporary directory");
    let t = fs::TempDir::new()?;
    
    // Write a requirements file into the temporary directory
    step("Writing requirements file");
    let reqfile = fs::File::create(t.path() + "/requirements.txt")?;
    reqfile.write("scipy\n");
    reqfile.sync();

    // Create a virtual environment in the temporary directory
    step("Preparing virtual environment");
    if let Ok(venv) = Venv::new(t.path() + "/.venv") {
        if !venv.exists() {
            step("Initializing virtual environment");
            venv.init();
        }

        // Install the requirements into the virtual environment; suppress the
        // output of pip
        step("Installing requirements");
        venv.quiet(true);
        venv.install_requirements(t.path() + "/requirements.txt");

        // Run the python interpreter in the venv; make sure that quiet is
        // disabled so that we can see potential output
        step("Running python interpreter");
        venv.quiet(false);
        let output = venv.run([venv.get_interpreter(), "-c", "import scipy"])?;
        if output.status() == 0 {
            println!("Success");
        }
    }
}

pub fn cfg_examples(args) {
    // Create a temporary directory (will be deleted when the object is dropped)
    step("Creating temporary directory");
    let t = fs::TempDir::new()?;
    
    // Write a config file into the temporary directory
    step("Writing config file");
    let cfgfile = fs::File::create(t.path() + "/config.toml")?;
    cfgfile.write("
        [core]
        version = \"0.1.0\"
        [core.dependencies]
        python = \"3.7.0\"
    ");
    cfgfile.sync();

    // Load the config file
    step("Loading config file");
    let cfg = toml::from_file(t.path() + "/config.toml")?;

    // Print the config file
    step("Printing values from the config");
    println!("core.version: {}", cfg.core.version);
    println!("core.dependencies.python: {}", cfg.core.dependencies.python);
}

pub fn net_examples(args) {
    // Send a dummy GET request and display the status code and response
    step("Sending an HTTP GET request");
    println!("GET https://reqres.in/api/users?page=2");
    let client = http::Client::new().get("https://reqres.in/api/users?page=2");
    let response = client.call()?;
    step("Printing the status");
    println!("Status: {}", response.status());
    step("Printing the payload");
    println!("Payload: {}", response.into_string()?);
    
    // Send a dummy POST request and display the status code and response
    step("Sending an HTTP POST request");
    println!("POST https://reqres.in/api/login");
    let client = http::Client::new().post("https://reqres.in/api/users");
    let response = client.send_string("{\"name\": \"johannes\", \"job\": \"architect\"}")?;
    step("Printing the status");
    println!("Status: {}", response.status());
    step("Printing the payload");
    println!("Payload: {}", response.into_string()?);
}

pub fn cmd_examples(args) {
    step("Run a command via argument vector");
    let c = cmd::Command::new("git").arg("--version");
    let output = c.execute()?;
    println!("{}", output.stdout());

    step("Run a command specified in a string");
    let cargs = cmd::split("git --version")?;
    let c = cmd::Command::new(cargs[0]).args(cargs.iter().skip(1).collect::<Vec>());
    let output = c.execute()?;
    println!("{}", output.stdout());

    step("Use the shell function from the core module");
    let output = core::shell("git --version")?;
    println!("{}", output.stdout());
}

pub fn regex_examples(args) {
    step("Match");
    let v = "1.4.7-beta";
    let re = regex::Regex::new("(\\d+)\\.(\\d+)\\.(\\d+)(-\\w+)?");
    println!("{}", re.is_match(v));

    step("Replace");
    let s = "2021-03-15, 2022-04-16 and 2023-05-17";
    let re = regex::Regex::new("(?P<y>\\d{4})-(?P<m>\\d{2})-(?P<d>\\d{2})");
    println!("{}", re.replace_all(s, "$m/$d/$y"));

    step("Find");
    let s = "Hello world!";
    let re = regex::Regex::new("w.+d");
    let m = re.find(s)?;
    println!("start {}, end {}, text '{}'", m.start(), m.end(), m.as_str());

    step("Find iter");
    let s = "This is a test string for the find iter function";
    let re = regex::Regex::new("f\\w*");
    let matches = re.find_iter(s);
    for m in matches {
        println!("{}", m.as_str());
    }

    step("Captures");
    let s = "size: small";
    let re = regex::Regex::new("(\\w+):\\s+(\\w+)");
    let c = re.captures(s)?;
    println!("key: {}, value: {}", c.get(1)?.as_str(), c.get(2)?.as_str());

    step("Captures iter");
    let s = "size: small, color: red, weight: 23";
    let re = regex::Regex::new("(\\w+):\\s+(\\w+)");
    let captures = re.captures_iter(s);
    for c in captures {
        if let Some(c) = c {
            println!("key: {}, value: {}", c.get(1)?.as_str(), c.get(2)?.as_str());
        }
    }
}

pub fn paint_examples(args) {
    println!("{}", str::paint("Hello world!").yellow().underline());
    println!("{}", str::paint("Hello world!").green().bold());
    println!("{}", str::paint("Hello world!").red().italic());
    println!("{} {}!", str::paint("Hello").green(), str::paint("world").red());
    println(`${str::paint("Hello").yellow()} ${str::paint("world").blue()}!`);
    println!("{}", str::paint("Hello").yellow().bold().on_blue());
}

pub fn tmpl_examples(args) {
    let context = #{size: "small", color: "red"};
    let t = "
{
    \"size\": \"{{ size }}\",
    \"color\": \"{{ color }}\"
}";
    let s = str::template(t, context).expect("Failed to render template");
    println!("{}", s);
}

