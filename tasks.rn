use arch::*;
use cmd::Command;
use regex::Regex;

mod testmod;

struct Global {
    tasks
}

impl Global {
    fn register(self, name, task) {
        self.tasks["name"] = task;
    }
}

fn paint(s) {
    let colored = Regex::new("<(\\w+)(?:,(\\w+))?\\|(.*?)>");
    let captures = colored.captures_iter(s);
    let last = 0;
    for cap in captures {
        if let Some(c) = cap {
            let full_start = c.get(0).unwrap().start();
            let full_end = c.get(0).unwrap().end();
            let color = c.get(1).unwrap().as_str();
            let style = None;
            let content = c.get(3).unwrap().as_str();
            if c.get(2).is_some() {
                style = Some(c.get(2).unwrap().as_str());
            }
            if full_start > last {
                let text = s[last..full_start];
                sys::write(text);
            }
            if style.is_some() {
                sys::write_colored(color, style.unwrap(), content);
            } else {
                sys::write_colored(color, "normal", content);
            }
            last = full_end;
        }
    }
    if last != s.len() {
        let text = s[last..s.len()];
        sys::write(text);
    }
}

pub fn mytask() {
    print("Hello from mytask!");
}

fn test_arch() {
    arch::create("test.tar.gz", "tests");
    arch::extract("test.tar.gz", "dummy");
    fs::delete("dummy");
}

fn run(cmd, args) {
    let command = Command::new(cmd);
    command.args(args);
    command.shell();
    command.output()
}

fn is_in_path(program) {
    let paths = ();
    if sys::is_windows() {
        paths = sys::env()["Path"].split(";");
        program = program + ".exe";
    } else {
        paths = sys::env()["PATH"].split(":");
    }
    
    for p in paths {
        if fs::is_file(join(p, program)) {
            return true;
        }
    }

    return false;
}

fn join(p1, p2) {
    let sep = "/";
    if sys::is_windows() {
        sep = "\\";
    }
    if p1.ends_with(sep) {
        return p1 + p2;
    } else {
        return p1 + sep + p2;
    }
}

fn path_variable() {
    if sys::is_windows() {
        "Path"
    } else {
        "PATH"
    }
}

struct Venv {
    path
}

impl Venv {
    fn run(self, command) {
        let c = Command::new(command[0]);
        c.shell();
        c.args(command.iter().skip(1).collect::<Vec>());
        c.env_remove("PYTHONHOME");
        let entry_separator = ":";
        let bin_dir = "bin";
        if sys::is_windows() {
            entry_separator = ";";
            bin_dir = "Scripts";
        }
        c.env(path_variable(), join(fs::absolute(self.path)?, bin_dir) + entry_separator + sys::env()[path_variable()]);
        c.execute();
    }
}

fn init_venv(path) {
    let python = "python3";
    
    if !is_in_path("python3") {
        python = "python";
    }
    
    if !is_in_path(python) {
        print("Python not found in PATH");
        return;
    }

    if !fs::is_dir(path) {
        run("python", ["-m", "venv", path]);
    } else {
        println(`venv already exists at ${path}`);
    }

    Venv {
        path: path
    }
}

pub fn main() {
    let venv = init_venv(".venv");
    venv.run(["python"]);
    let abs = fs::absolute("tasks.rn");
    println(abs?);
    let p = run("echo", ["test", "bla"]);
    println(p);
    paint("<red,underline|das> ist ein <blue,bold|test>\n");
    tasks::register("blubb", mytask);
    let global = Global {
        tasks: #{}
    };
    global.register("blubb", mytask);
    testmod::test();
}

fn build() {
    println!("-- build");
}

fn test() {
    println!("-- test");
}

pub fn metabuild() {
    tasks::register("build", build);
    tasks::register("test", test);
}